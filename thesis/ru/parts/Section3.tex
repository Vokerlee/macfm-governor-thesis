\section{Исследование и построение решения задачи}
\label{sec:Section3} \index{Section3}

\subsection{Описание модели производительности процессора}

    Главной характеристикой производительности процессора является количество инструкций,
    исполняемых в еденицу времени -- чем больше это значение, тем быстрее исполняется рабочая
    нагрузка (программа). Причём заданное количество инструкций исполняются за разное количество
    процессорных циклов, которые обратно пропорциональны времени исполнения этих инструкций.

    Пусть за время $\tau$ процессор исполнил $instrs$ инструкций за $cycles$ циклов при заданной
    частоте процессора $freq_{cpu}$. Тогда, очевидно, выполняется следующее соотношение:

    \begin{equation} \label{cycles_base}
        cycles = \frac{freq_{cpu}}{\tau}
    \end{equation}

    На практике чаще всего используют такие соотношения как $cpi = cycles / instrs$ и
    $ipc = instrs / cycles$ как мера производительности процессора: чем выше/ниже значение
    $ipc$/$cpi$, тем лучше процессор. Однако кроме типа процессорного ядра на эти значения также
    влияют частота самого ядра и частоты остальных компонент системы. Например, при повышении частоты
    процессора величина $ipc$ либо остаётся такой же, что возможно при так называемой cpu-bound
    нагрузке (непосредственно связанной с исполнением на самом ядре), либо уменьшается, что
    характерно для memory-bound нагрузок (процессор часто обращается в кеши или оперативную память,
    из-за чего циклы тратятся впустую).

    За время $\tau$ процессор часть циклов тратит на исполнение инструкций непосредственно на
    процессорных блоках (в том числе вычислительных), а оставшуюся часть на ожидание операций, связанных
    с обращением в память (в кеши или оперативную память): обозначим эти величины $cycles_{cpu}$ и
    $cycles_{mem}$, тогда справедливо

    \begin{equation}
        cpi = \frac{cycles}{instrs} = \frac{cycles_{cpu}}{instrs} + \frac{cycles_{mem}}{instrs}
    \end{equation}

    Важно отметить, что $\frac{cycles_{cpu}}{instrs}$ -- значение $cpi$, если бы все обращения
    в кеши и оперативную память занимали 0 циклов, т.е. работали бы бесконечно быстро, а значит
    количество циклов ограничивалось снизу возможностями процессора. Обозначим данное соотношение
    как $cpi_{cpu} \equiv \frac{cycles_{cpu}}{instrs}$.

    В свою очередь величина $cycles_{mem}$ характеризуется только лишь внешними компонентами системы,
    не зависящими от процессора. Пусть, например, если имеется 2 уровня кешей и оперативная память.
    Время доступа к определённому уровню кеша характеризуется средней величиной $cycles_{L_{i}}$,
    представляющую собой латентность кеша (время задержки обращения), выраженную в процессорных
    циклах, где $i$ -- номер уровня кеша.
    После обращения в кеш возможны 2 ситуации: либо попадание к кеш, либо промах и обращение в
    следующий уровень кеша или оперативную память.
    Время доступа к оперативной памяти обозначим $cycles_{ram}$.

    Выражая времена доступа через собственные частоты и латентности, получим:

    \begin{equation}
        cycles_{mem} = n_{L_1} \cdot \frac{lat_{L_1}}{freq_{L_1}} \cdot freq_{cpu} +
        n_{L_2} \cdot \frac{lat_{L_2}}{freq_{L_2}} \cdot freq_{cpu} +
        n_{ram} \cdot \frac{lat_{ram}}{freq_{ram}} \cdot freq_{cpu},
    \end{equation}

    \begin{equation}
        cpi = cpi_{cpu} + \frac{n_{L_1} \cdot \frac{lat_{L_1}}{freq_{L_1}} +
        n_{L_2} \cdot \frac{lat_{L_2}}{freq_{L_2}} +
        n_{ram} \cdot \frac{lat_{ram}}{freq_{ram}}}{instrs} \cdot freq_{cpu},
    \end{equation}

    где $lat_{L_1}$, $lat_{L_2}$ и $lat_{ram}$ -- латентости, выраженные в собственных циклах
    (а не процессорных), а $n_{L_1}$, $n_{L_2}$ и $n_{ram}$ -- количество обращений к соответствующим
    уровням кешей или оперативной памяти за время $\tau$.

    Заметим, что из формулы следует, что повышение частоты процессора ведёт к увеличению $cpi$
    и уменьшению $ipc$, а повышение частот кешей и оперативной памяти, наоборот, ведёт к
    уменьшению $cpi$ и увеличению $ipc$.

    Чаще всего уровни кешей, наиболее близкие к процессорному ядру, имеют такой же источник
    тактирования, что и процессорное ядро, т.е. такие кеши оперируют на тех же частотах, что и
    сам процессор. Например, если бы кеш L1 оперировал с частотами процессора
    ($freq_{L_1} = freq_{cpu}$), тогда

    \begin{equation}
        cpi = cpi_{cpu} + n_{L_1} \cdot \frac{lat_{L_1}}{instrs} + \frac{\frac{lat_{L_2}}{freq_{L_2}} +
        \frac{lat_{ram}}{freq_{ram}}}{instrs} \cdot freq_{cpu} =
    \end{equation}

    \begin{equation}
        = cpi_{cpu}^{L_1} + \frac{\frac{lat_{L_2}}{freq_{L_2}} +
        \frac{lat_{ram}}{freq_{ram}}}{instrs} \cdot freq_{cpu},
    \end{equation}

    то есть можно занести константную часть для заданной нагрузки, незавсимую от каких-либо частот,
    в $cpu_{cpu}$, что упрощает формулу. Однако, теперь $cpi_{cpu}^{L_1}$ зависит не только от характера
    утилизации нагрузкой процессорных блоков, как $cpi_{cpu}$, но также и от характеристик кеша L1 и
    количества обращений в него (т.е. от уровня его утилизации).

\newpage
