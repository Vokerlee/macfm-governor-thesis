\section{Исследование и построение решения задачи}
\label{sec:Section3} \index{Section3}

\subsection{Описание модели производительности процессора}

    Главной характеристикой производительности процессора является количество инструкций,
    исполняемых в еденицу времени -- чем больше это значение, тем быстрее исполняется рабочая
    нагрузка (программа). Причём заданное количество инструкций исполнется за разное количество
    процессорных циклов, которое, в свою очередь, обратно пропорциональны времени исполнения
    этих инструкций.

    Пусть за время $\tau$ процессор исполнил $instrs$ инструкций за $cycles$ циклов при заданной
    частоте процессора $freq_{cpu}$. Тогда, очевидно, выполняется следующее соотношение:

    \begin{equation} \label{cycles_base}
        cycles = \frac{freq_{cpu}}{\tau}
    \end{equation}

    На практике чаще всего используют такие величины как $cpi = cycles / instrs$ и
    $ipc = instrs / cycles$ в качестве меры производительности процессора: чем выше/ниже значение
    $ipc$/$cpi$, тем лучше процессор. Однако кроме типа процессорного ядра на эти значения также
    влияют частота самого ядра и частоты остальных компонент системы. Например, при повышении частоты
    процессора величина $ipc$ либо остаётся такой же, что возможно при так называемой cpu-bound
    нагрузке (непосредственно связанной с исполнением на самом ядре), либо уменьшается, что
    характерно для memory-bound нагрузок (процессор часто обращается в кеши или оперативную память,
    из-за чего циклы тратятся впустую).

    За время $\tau$ процессор часть циклов тратит на исполнение инструкций непосредственно на
    процессорных блоках (в том числе вычислительных), а оставшуюся часть на ожидание операций,
    связанных с обращением в память (в кеши или оперативную память): обозначим эти величины
    $cycles_{cpu}$ и $cycles_{mem}$, тогда справедливо

    \begin{equation}
        cpi = \frac{cycles}{instrs} = \frac{cycles_{cpu}}{instrs} + \frac{cycles_{mem}}{instrs}
    \end{equation}

    Важно отметить, что $\frac{cycles_{cpu}}{instrs}$ -- значение $cpi$, если бы все обращения
    в кеши и оперативную память занимали 0 циклов, т.е. работали бы бесконечно быстро, а значит
    количество циклов ограничивалось снизу возможностями процессора. Обозначим данное соотношение
    как $cpi_{cpu} \equiv \frac{cycles_{cpu}}{instrs}$.

    В свою очередь величина $cycles_{mem}$ характеризуется только лишь внешними компонентами системы,
    не зависящими от процессора. Пусть, например, если имеется 2 уровня кешей и оперативная память.
    Время доступа к определённому уровню кеша характеризуется средней величиной $cycles_{L_{i}}$,
    представляющую собой латентность кеша (время задержки обращения), выраженную в процессорных
    циклах, где $i$ -- номер уровня кеша.
    После обращения в кеш возможны 2 ситуации: либо попадание к кеш, либо промах и обращение в
    следующий уровень кеша или оперативную память.
    Время доступа к оперативной памяти обозначим $cycles_{ram}$.

    Выражая времена доступа через собственные частоты и латентности, получим:

    \begin{equation}
        cycles_{mem} = n_{L_1} \cdot \frac{lat_{L_1}}{freq_{L_1}} \cdot freq_{cpu} +
        n_{L_2} \cdot \frac{lat_{L_2}}{freq_{L_2}} \cdot freq_{cpu} +
        n_{ram} \cdot \frac{lat_{ram}}{freq_{ram}} \cdot freq_{cpu},
    \end{equation}

    \begin{equation}
        cpi = cpi_{cpu} + \frac{n_{L_1} \cdot \frac{lat_{L_1}}{freq_{L_1}} +
        n_{L_2} \cdot \frac{lat_{L_2}}{freq_{L_2}} +
        n_{ram} \cdot \frac{lat_{ram}}{freq_{ram}}}{instrs} \cdot freq_{cpu},
    \end{equation}
    где $lat_{L_1}$, $lat_{L_2}$ и $lat_{ram}$ -- латентности, выраженные в собственных циклах
    (а не процессорных), а $n_{L_1}$, $n_{L_2}$ и $n_{ram}$ -- количество обращений к
    соответствующим уровням кешей или оперативной памяти за время $\tau$.

    Заметим, что из формулы следует, что повышение частоты процессора ведёт к увеличению $cpi$
    и уменьшению $ipc$, а повышение частот кешей и оперативной памяти, наоборот, ведёт к
    уменьшению $cpi$ и увеличению $ipc$.

    Чаще всего уровни кешей, наиболее близкие к процессорному ядру, имеют такой же источник
    тактирования, что и процессорное ядро, т.е. такие кеши оперируют на тех же частотах, что и
    сам процессор. Например, если бы кеш L1 оперировал с частотами процессора
    ($freq_{L_1} = freq_{cpu}$), тогда формулу можно упростить до более простой:

    \begin{equation}
        cpi = cpi_{cpu} + n_{L_1} \cdot \frac{lat_{L_1}}{instrs} +
        \frac{n_{L_2} \cdot \frac{lat_{L_2}}{freq_{L_2}} +
        n_{ram} \cdot \frac{lat_{ram}}{freq_{ram}}}{instrs} \cdot freq_{cpu} =
    \end{equation}

    \begin{equation}
        = cpi_{cpu}^{L_1} + \frac{n_{L_2} \cdot \frac{lat_{L_2}}{freq_{L_2}} +
        n_{ram} \cdot \frac{lat_{ram}}{freq_{ram}}}{instrs} \cdot freq_{cpu},
    \end{equation}
    то есть можно занести константную часть для заданной нагрузки, незавсимую от каких-либо
    частот, в $cpi_{cpu}$, что упрощает формулу. Однако, теперь $cpi_{cpu}^{L_1}$ зависит
    не только от характера утилизации нагрузкой процессорных блоков, как $cpi_{cpu}$, но
    также и от характеристик кеша L1 и количества обращений в него (т.е. от уровня его утилизации).

    Латентности кешей и оперативной памяти могут и не быть константными значениями, т.к.
    могут зависеть от характера и частоты обращений к ним. Так, латентность оперативной
    памяти определяется как текущим уровнем утилизации этой памяти (зависимость latency от
    bandwidth), так и особенностями обращения к ней (например, в случае DDR памяти,
    где элементарными ячейками являются банки данных, состоящие из строк и столбцов,
    существует кеш строки, который значительно влияет на скорость обращения
    к ячейке памяти, т.е. локальность обращения к ячейке DDR памяти очень важна).

    У описываемой модели есть ряд преимуществ, которые делают её лучше аналогичных моделей:
    \begin{enumerate}
        \item Построив модели, с помощью которых можно вычислять $lat_{L_2}$ и $lat_{ram}$,
        в режиме реального времени можно вычислить величину $cpi_{cpu}^{L_1}$ для
        заданной нагрузки без построения соответствующей модели: достаточно знать значения
        $cycles$, $instrs$, $n_{L_2}$ и $n_{ram}$.
        \item Зная величину $cpi_{cpu}^{L_1}$, можно вычислить $cpi$ (а значит и $ipc$)
        для любого набора частот процессора и прочих компонент, частоты которых входят в
        вышеописываемую формулу, причём не требуются знания о характере событий,
        происходящих внутри процессора, и даже о событиях, происходящих внутри кеша уровня L1.
        \item В случае физического ядра, разделённого на 2 виртуальных (так называемый
        SMT - Simultaneous multithreading), по-прежнему можно пользоваться формулой выше, т.к.
        становится неважно, как именно виртуальные ядра разделяют между собой процессорные блоки
        и как именно они взаимодействуют с кешом уровня L1.
    \end{enumerate}

    Таким образом, для применения модели необходимо:
    \begin{enumerate}
        \item Иметь готовые модели для поиска $lat_{L_2}$, $lat_{ram}$.
        \item Уметь каким-либо образом вычислять значения $cycles$, $instrs$, $n_{L_2}$ и $n_{ram}$.
        \item Знать списки возможных частот $freq_{cpu}$, $freq_{ram}$, $freq_{L_2}$.
    \end{enumerate}

\subsection{Модель производительности применительно к архитектуре ARM}

    Рассмотрим способ применения описанной выше модели в случае архитектуры ARM.
    Для подсчёта значений $cycles$, $instrs$, $n_{L_2}$ и $n_{ram}$ можно ипользовать
    следующие PMU счётчики процессора:
    \begin{enumerate}
        \item $CPU\_CYCLES$ -- количество затраченных процессорных циклов;
        \item $INST\_RETIRED$ -- количество исполненных инструкций;
        \item $L1I\_CACHE\_REFILL$ -- количество чтений инструкций (instruction fetches),
        которые отсутствуют в кеше инструкций уровня L1 (промах в L1 кеш инструкций),
        поэтому инструкции вынуждены читаться из кешей более высокого уровня.
        Некешируемые промахи в кеш и операции синхронизации кешей не считаются;
        \item $L1D\_CACHE\_REFILL$ -- количество чтений и записей данных (data loads and stores),
        или операций обращений в таблицу страниц (page table walks), которые не смогли
        найти нужную информацию в кеше данных уровня L1 (промах в L1 кеш данных),
        поэтому данные вынуждены выгружаться из кешей более высокого уровня.
        Некешируемые промахи в кеш и операции синхронизации кешей не считаются;
        \item $L2D\_CACHE\_REFILL$ -- работает как сумма счётиков $L1D\_CACHE\_REFILL$ \\ и
        $L1I\_CACHE\_REFILL$, но применительно к уровню кеша L2. В случае промаха в кеш дальнейшее
        обращение может происходить не в кеш более высокого уровня, если таковой отсутствует,
        а сразу в оперативную память.
    \end{enumerate}

    В счётчиках типа $\_CACHE\_REFILL$ существует очень важный нюанс, не оговорённый
    в спецификациях PMU счётчиков компании ARM Ltd.,
    но упоминаемый в иных документах: в платформах архитектуры ARM не существует PMU
    счётчиков, которые считают промахи в кеши, вместо них используются счётчики, считающие
    количество перезапонений кеш-линий (кешами более выского уровня ил оперативной памятью).
    Возможна ситуация, когда один промах в кеш вызывает
    несколько перезаполнений кеш-линий (например, если промах случился по адресу,
    который пересекает 2 соседние кеш-линии), или наоборот: несколько промахов
    в кеш могут быть разрешены благодаря одному перезаполнению кеш-линии.

    Заметим, что чаще всего в современных мобильных системах на архитектуре ARM после последнего
    уровня процессорного кеша располагают дополнительный кеш -- системный кеш (system cache),
    который предназначен для периферийных устройств. Он может быть как больше по размеру, чем
    последний уровень процессорного кеша, так и меньше. Наличия системного кеша ведёт к тому,
    что для определения значения $n_{ram}$ недостаточно воспользоваться счётчиками, описанными
    выше.

    Единственный счётчик, который умеет считать количество промахов в кеш, является
    $LL\_CACHE\_MISS\_RD$. Причиной тому является то, что кеш последнего уровня, как правило,
    является системным кешом, который находится за пределами CPU на чипе. Данный счётчик считает
    количество промахов, когда в результате данные берутся из оперативной памяти,
    из другого чипа или из соседнего процессорного кластера с использованием технологии
    Intercluster peering. Нас интересует только первый случай.

    Согласно документации ARM, если счётчик $LL\_CACHE\_MISS\_RD$ не реализован, то есть
    бит $EXTLLC$ в регистре $CPUECTLR$ выставлен в ноль, то значения $LL\_CACHE\_MISS\_RD$
    будут совпадать со значениями $L2D\_CACHE\_REFILL$, так что в случае наличия
    системного кеша такая ситуация может заметно ухудшить работу модели
    (по-прежнему предполагается система из 2 уровней кеша и возможно системного кеша).

\subsection{Модель производительности применительно к ядру Linux}



\subsection{Реализация модели в планировщике ядра Linux}




\newpage
